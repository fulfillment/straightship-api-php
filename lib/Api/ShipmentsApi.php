<?php
/**
 * ShipmentsApi
 * PHP version 5
 *
 * @category Class
 * @package  namespace Fulfillment\StraightShip\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Techship API v3
 *
 * API regions:  US: <a href='https://api-us.techship.io/api/docs/ui/index'>https://api-us.techship.io/api/docs/ui/index</a>  CA: <a href='https://api-ca.techship.io/api/docs/ui/index'>https://api-ca.techship.io/api/docs/ui/index</a>
 *
 * OpenAPI spec version: V3
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.61
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Fulfillment\StraightShip\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Fulfillment\StraightShip\Client\ApiException;
use Fulfillment\StraightShip\Client\Configuration;
use Fulfillment\StraightShip\Client\HeaderSelector;
use Fulfillment\StraightShip\Client\ObjectSerializer;
use Fulfillment\StraightShip\Client\Model\Order;
use Fulfillment\StraightShip\Client\Model\ApiError;
use Fulfillment\StraightShip\Client\Model\OperationResult;
use Fulfillment\StraightShip\Client\Model\RatesResult;
use Fulfillment\StraightShip\Client\Model\VoidShipmentResult;
use Fulfillment\StraightShip\Client\Model\CreateLabelResult;
use Fulfillment\StraightShip\Client\Model\CartonizeResult;

/**
 * ShipmentsApi Class Doc Comment
 *
 * @category Class
 * @package  namespace Fulfillment\StraightShip\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class ShipmentsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation callPrint
     *
     * Send shipment to printer (requires desktop client)
     *
     * @param  string $printer_key Printer key (required)
     * @param  int $shipment_id shipment_id (optional)
     * @param  string $transaction_number transaction_number (optional)
     * @param  string $customer_order customer_order (optional)
     * @param  string $batch_number batch_number (optional)
     * @param  string $customer_po customer_po (optional)
     *
     * @throws \Fulfillment\StraightShip\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function callPrint($printer_key, $shipment_id = null, $transaction_number = null, $customer_order = null, $batch_number = null, $customer_po = null)
    {
        list($response) = $this->callPrintWithHttpInfo($printer_key, $shipment_id, $transaction_number, $customer_order, $batch_number, $customer_po);
        return $response;
    }

    /**
     * Operation callPrintWithHttpInfo
     *
     * Send shipment to printer (requires desktop client)
     *
     * @param  string $printer_key Printer key (required)
     * @param  int $shipment_id (optional)
     * @param  string $transaction_number (optional)
     * @param  string $customer_order (optional)
     * @param  string $batch_number (optional)
     * @param  string $customer_po (optional)
     *
     * @throws \Fulfillment\StraightShip\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function callPrintWithHttpInfo($printer_key, $shipment_id = null, $transaction_number = null, $customer_order = null, $batch_number = null, $customer_po = null)
    {
        $returnType = 'object';
        $request = $this->callPrintRequest($printer_key, $shipment_id, $transaction_number, $customer_order, $batch_number, $customer_po);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation callPrintAsync
     *
     * Send shipment to printer (requires desktop client)
     *
     * @param  string $printer_key Printer key (required)
     * @param  int $shipment_id (optional)
     * @param  string $transaction_number (optional)
     * @param  string $customer_order (optional)
     * @param  string $batch_number (optional)
     * @param  string $customer_po (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function callPrintAsync($printer_key, $shipment_id = null, $transaction_number = null, $customer_order = null, $batch_number = null, $customer_po = null)
    {
        return $this->callPrintAsyncWithHttpInfo($printer_key, $shipment_id, $transaction_number, $customer_order, $batch_number, $customer_po)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation callPrintAsyncWithHttpInfo
     *
     * Send shipment to printer (requires desktop client)
     *
     * @param  string $printer_key Printer key (required)
     * @param  int $shipment_id (optional)
     * @param  string $transaction_number (optional)
     * @param  string $customer_order (optional)
     * @param  string $batch_number (optional)
     * @param  string $customer_po (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function callPrintAsyncWithHttpInfo($printer_key, $shipment_id = null, $transaction_number = null, $customer_order = null, $batch_number = null, $customer_po = null)
    {
        $returnType = 'object';
        $request = $this->callPrintRequest($printer_key, $shipment_id, $transaction_number, $customer_order, $batch_number, $customer_po);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'callPrint'
     *
     * @param  string $printer_key Printer key (required)
     * @param  int $shipment_id (optional)
     * @param  string $transaction_number (optional)
     * @param  string $customer_order (optional)
     * @param  string $batch_number (optional)
     * @param  string $customer_po (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function callPrintRequest($printer_key, $shipment_id = null, $transaction_number = null, $customer_order = null, $batch_number = null, $customer_po = null)
    {
        // verify the required parameter 'printer_key' is set
        if ($printer_key === null || (is_array($printer_key) && count($printer_key) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $printer_key when calling callPrint'
            );
        }

        $resourcePath = '/api/v3/shipments/print';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($printer_key !== null) {
            $queryParams['printerKey'] = ObjectSerializer::toQueryValue($printer_key, null);
        }
        // query params
        if ($shipment_id !== null) {
            $queryParams['shipmentId'] = ObjectSerializer::toQueryValue($shipment_id, 'int32');
        }
        // query params
        if ($transaction_number !== null) {
            $queryParams['transactionNumber'] = ObjectSerializer::toQueryValue($transaction_number, null);
        }
        // query params
        if ($customer_order !== null) {
            $queryParams['customerOrder'] = ObjectSerializer::toQueryValue($customer_order, null);
        }
        // query params
        if ($batch_number !== null) {
            $queryParams['batchNumber'] = ObjectSerializer::toQueryValue($batch_number, null);
        }
        // query params
        if ($customer_po !== null) {
            $queryParams['customerPO'] = ObjectSerializer::toQueryValue($customer_po, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-secret-key');
        if ($apiKey !== null) {
            $headers['x-secret-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cartonizeShipment
     *
     * Cartonize unpacked shipment
     *
     * @param \Fulfillment\StraightShip\Client\Model\InputUnpackedOrder $body Shipment  to create (required)
     * @param  string $duplicate_handling Duplicate handling ( by transaction number)              0 - Exception on duplicate (default)              1 - Allow duplicates               2 - Overwrite if duplicate not closed              3 - System reserved for internal use              4 - Overwrite if duplicate not in processed state              5 - Return existing label if processed, otherwise overwrite (optional, default to Exception)
     * @param  string $error_label_mode Error label modeL 0 - None, 1 - PDF, 2 - ZPL (optional, default to None)
     * @param  string $label_pdf_conversion Label pdf conversion: 0 - Default, 1 - Enabled, 2 - Disabled (optional, default to Default)
     * @param  string $label_preference Label preference (support depends on carrier): 0 - ZPL, 1 - PDF, 2 - AZPL, 3 - BZPL, 4 - EPL, 5 - DPL, 6 - PDF (optional)
     * @param  bool $is_quote is_quote (optional)
     * @param  bool $no_lock Do not use distributed locking for duplicate check (if used, duplicate check should be done by calling system) (optional, default to false)
     * @param  bool $import_only Import order and leave in not processed state (optional, default to false)
     * @param  bool $label_url Generate labels as URL (for internal use only) (optional, default to false)
     * @param  bool $dry_run Do not save results to database (optional, default to false)
     * @param  string $printer_key Id of printer used to process order (optional)
     *
     * @throws \Fulfillment\StraightShip\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Fulfillment\StraightShip\Client\Model\CartonizeResult
     */
    public function cartonizeShipment($body, $duplicate_handling = 'Exception', $error_label_mode = 'None', $label_pdf_conversion = 'Default', $label_preference = null, $is_quote = null, $no_lock = 'false', $import_only = 'false', $label_url = 'false', $dry_run = 'false', $printer_key = null)
    {
        list($response) = $this->cartonizeShipmentWithHttpInfo($body, $duplicate_handling, $error_label_mode, $label_pdf_conversion, $label_preference, $is_quote, $no_lock, $import_only, $label_url, $dry_run, $printer_key);
        return $response;
    }

    /**
     * Operation cartonizeShipmentWithHttpInfo
     *
     * Cartonize unpacked shipment
     *
     * @param \Fulfillment\StraightShip\Client\Model\InputUnpackedOrder $body Shipment  to create (required)
     * @param  string $duplicate_handling Duplicate handling ( by transaction number)              0 - Exception on duplicate (default)              1 - Allow duplicates               2 - Overwrite if duplicate not closed              3 - System reserved for internal use              4 - Overwrite if duplicate not in processed state              5 - Return existing label if processed, otherwise overwrite (optional, default to Exception)
     * @param  string $error_label_mode Error label modeL 0 - None, 1 - PDF, 2 - ZPL (optional, default to None)
     * @param  string $label_pdf_conversion Label pdf conversion: 0 - Default, 1 - Enabled, 2 - Disabled (optional, default to Default)
     * @param  string $label_preference Label preference (support depends on carrier): 0 - ZPL, 1 - PDF, 2 - AZPL, 3 - BZPL, 4 - EPL, 5 - DPL, 6 - PDF (optional)
     * @param  bool $is_quote (optional)
     * @param  bool $no_lock Do not use distributed locking for duplicate check (if used, duplicate check should be done by calling system) (optional, default to false)
     * @param  bool $import_only Import order and leave in not processed state (optional, default to false)
     * @param  bool $label_url Generate labels as URL (for internal use only) (optional, default to false)
     * @param  bool $dry_run Do not save results to database (optional, default to false)
     * @param  string $printer_key Id of printer used to process order (optional)
     *
     * @throws \Fulfillment\StraightShip\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of Fulfillment\StraightShip\Client\Model\CartonizeResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function cartonizeShipmentWithHttpInfo($body, $duplicate_handling = 'Exception', $error_label_mode = 'None', $label_pdf_conversion = 'Default', $label_preference = null, $is_quote = null, $no_lock = 'false', $import_only = 'false', $label_url = 'false', $dry_run = 'false', $printer_key = null)
    {
        $returnType = CartonizeResult::class;
        $request = $this->cartonizeShipmentRequest($body, $duplicate_handling, $error_label_mode, $label_pdf_conversion, $label_preference, $is_quote, $no_lock, $import_only, $label_url, $dry_run, $printer_key);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        CartonizeResult::class,
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cartonizeShipmentAsync
     *
     * Cartonize unpacked shipment
     *
     * @param \Fulfillment\StraightShip\Client\Model\InputUnpackedOrder $body Shipment  to create (required)
     * @param  string $duplicate_handling Duplicate handling ( by transaction number)              0 - Exception on duplicate (default)              1 - Allow duplicates               2 - Overwrite if duplicate not closed              3 - System reserved for internal use              4 - Overwrite if duplicate not in processed state              5 - Return existing label if processed, otherwise overwrite (optional, default to Exception)
     * @param  string $error_label_mode Error label modeL 0 - None, 1 - PDF, 2 - ZPL (optional, default to None)
     * @param  string $label_pdf_conversion Label pdf conversion: 0 - Default, 1 - Enabled, 2 - Disabled (optional, default to Default)
     * @param  string $label_preference Label preference (support depends on carrier): 0 - ZPL, 1 - PDF, 2 - AZPL, 3 - BZPL, 4 - EPL, 5 - DPL, 6 - PDF (optional)
     * @param  bool $is_quote (optional)
     * @param  bool $no_lock Do not use distributed locking for duplicate check (if used, duplicate check should be done by calling system) (optional, default to false)
     * @param  bool $import_only Import order and leave in not processed state (optional, default to false)
     * @param  bool $label_url Generate labels as URL (for internal use only) (optional, default to false)
     * @param  bool $dry_run Do not save results to database (optional, default to false)
     * @param  string $printer_key Id of printer used to process order (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cartonizeShipmentAsync($body, $duplicate_handling = 'Exception', $error_label_mode = 'None', $label_pdf_conversion = 'Default', $label_preference = null, $is_quote = null, $no_lock = 'false', $import_only = 'false', $label_url = 'false', $dry_run = 'false', $printer_key = null)
    {
        return $this->cartonizeShipmentAsyncWithHttpInfo($body, $duplicate_handling, $error_label_mode, $label_pdf_conversion, $label_preference, $is_quote, $no_lock, $import_only, $label_url, $dry_run, $printer_key)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cartonizeShipmentAsyncWithHttpInfo
     *
     * Cartonize unpacked shipment
     *
     * @param \Fulfillment\StraightShip\Client\Model\InputUnpackedOrder $body Shipment  to create (required)
     * @param  string $duplicate_handling Duplicate handling ( by transaction number)              0 - Exception on duplicate (default)              1 - Allow duplicates               2 - Overwrite if duplicate not closed              3 - System reserved for internal use              4 - Overwrite if duplicate not in processed state              5 - Return existing label if processed, otherwise overwrite (optional, default to Exception)
     * @param  string $error_label_mode Error label modeL 0 - None, 1 - PDF, 2 - ZPL (optional, default to None)
     * @param  string $label_pdf_conversion Label pdf conversion: 0 - Default, 1 - Enabled, 2 - Disabled (optional, default to Default)
     * @param  string $label_preference Label preference (support depends on carrier): 0 - ZPL, 1 - PDF, 2 - AZPL, 3 - BZPL, 4 - EPL, 5 - DPL, 6 - PDF (optional)
     * @param  bool $is_quote (optional)
     * @param  bool $no_lock Do not use distributed locking for duplicate check (if used, duplicate check should be done by calling system) (optional, default to false)
     * @param  bool $import_only Import order and leave in not processed state (optional, default to false)
     * @param  bool $label_url Generate labels as URL (for internal use only) (optional, default to false)
     * @param  bool $dry_run Do not save results to database (optional, default to false)
     * @param  string $printer_key Id of printer used to process order (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cartonizeShipmentAsyncWithHttpInfo($body, $duplicate_handling = 'Exception', $error_label_mode = 'None', $label_pdf_conversion = 'Default', $label_preference = null, $is_quote = null, $no_lock = 'false', $import_only = 'false', $label_url = 'false', $dry_run = 'false', $printer_key = null)
    {
        $returnType = CartonizeResult::class;
        $request = $this->cartonizeShipmentRequest($body, $duplicate_handling, $error_label_mode, $label_pdf_conversion, $label_preference, $is_quote, $no_lock, $import_only, $label_url, $dry_run, $printer_key);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cartonizeShipment'
     *
     * @param \Fulfillment\StraightShip\Client\Model\InputUnpackedOrder $body Shipment  to create (required)
     * @param  string $duplicate_handling Duplicate handling ( by transaction number)              0 - Exception on duplicate (default)              1 - Allow duplicates               2 - Overwrite if duplicate not closed              3 - System reserved for internal use              4 - Overwrite if duplicate not in processed state              5 - Return existing label if processed, otherwise overwrite (optional, default to Exception)
     * @param  string $error_label_mode Error label modeL 0 - None, 1 - PDF, 2 - ZPL (optional, default to None)
     * @param  string $label_pdf_conversion Label pdf conversion: 0 - Default, 1 - Enabled, 2 - Disabled (optional, default to Default)
     * @param  string $label_preference Label preference (support depends on carrier): 0 - ZPL, 1 - PDF, 2 - AZPL, 3 - BZPL, 4 - EPL, 5 - DPL, 6 - PDF (optional)
     * @param  bool $is_quote (optional)
     * @param  bool $no_lock Do not use distributed locking for duplicate check (if used, duplicate check should be done by calling system) (optional, default to false)
     * @param  bool $import_only Import order and leave in not processed state (optional, default to false)
     * @param  bool $label_url Generate labels as URL (for internal use only) (optional, default to false)
     * @param  bool $dry_run Do not save results to database (optional, default to false)
     * @param  string $printer_key Id of printer used to process order (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function cartonizeShipmentRequest($body, $duplicate_handling = 'Exception', $error_label_mode = 'None', $label_pdf_conversion = 'Default', $label_preference = null, $is_quote = null, $no_lock = 'false', $import_only = 'false', $label_url = 'false', $dry_run = 'false', $printer_key = null)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling cartonizeShipment'
            );
        }

        $resourcePath = '/api/v3/shipments/cartonize';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($duplicate_handling !== null) {
            $queryParams['duplicateHandling'] = ObjectSerializer::toQueryValue($duplicate_handling, null);
        }
        // query params
        if ($error_label_mode !== null) {
            $queryParams['errorLabelMode'] = ObjectSerializer::toQueryValue($error_label_mode, null);
        }
        // query params
        if ($label_pdf_conversion !== null) {
            $queryParams['labelPdfConversion'] = ObjectSerializer::toQueryValue($label_pdf_conversion, null);
        }
        // query params
        if ($label_preference !== null) {
            $queryParams['labelPreference'] = ObjectSerializer::toQueryValue($label_preference, null);
        }
        // query params
        if ($is_quote !== null) {
            $queryParams['isQuote'] = ObjectSerializer::toQueryValue($is_quote, null);
        }
        // query params
        if ($no_lock !== null) {
            $queryParams['noLock'] = ObjectSerializer::toQueryValue($no_lock, null);
        }
        // query params
        if ($import_only !== null) {
            $queryParams['importOnly'] = ObjectSerializer::toQueryValue($import_only, null);
        }
        // query params
        if ($label_url !== null) {
            $queryParams['labelUrl'] = ObjectSerializer::toQueryValue($label_url, null);
        }
        // query params
        if ($dry_run !== null) {
            $queryParams['dryRun'] = ObjectSerializer::toQueryValue($dry_run, null);
        }
        // query params
        if ($printer_key !== null) {
            $queryParams['printerKey'] = ObjectSerializer::toQueryValue($printer_key, null);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml'],
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-secret-key');
        if ($apiKey !== null) {
            $headers['x-secret-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation countShipment
     *
     * Count
     *
     * @param  string $start_date Start date, required (max range is 31 days) (required)
     * @param  string $end_date End date, required (max range is 31 days) (required)
     * @param  string $date_type Date type: ProcessedOn (default), CreatedOn, ShipDate (optional)
     * @param  string $client_code Client code (optional)
     * @param  string $carrier_code Carrier code (optional)
     *
     * @throws \Fulfillment\StraightShip\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return int
     */
    public function countShipment($start_date, $end_date, $date_type = null, $client_code = null, $carrier_code = null)
    {
        list($response) = $this->countShipmentWithHttpInfo($start_date, $end_date, $date_type, $client_code, $carrier_code);
        return $response;
    }

    /**
     * Operation countShipmentWithHttpInfo
     *
     * Count
     *
     * @param  string $start_date Start date, required (max range is 31 days) (required)
     * @param  string $end_date End date, required (max range is 31 days) (required)
     * @param  string $date_type Date type: ProcessedOn (default), CreatedOn, ShipDate (optional)
     * @param  string $client_code Client code (optional)
     * @param  string $carrier_code Carrier code (optional)
     *
     * @throws \Fulfillment\StraightShip\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function countShipmentWithHttpInfo($start_date, $end_date, $date_type = null, $client_code = null, $carrier_code = null)
    {
        $returnType = 'int';
        $request = $this->countShipmentRequest($start_date, $end_date, $date_type, $client_code, $carrier_code);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation countShipmentAsync
     *
     * Count
     *
     * @param  string $start_date Start date, required (max range is 31 days) (required)
     * @param  string $end_date End date, required (max range is 31 days) (required)
     * @param  string $date_type Date type: ProcessedOn (default), CreatedOn, ShipDate (optional)
     * @param  string $client_code Client code (optional)
     * @param  string $carrier_code Carrier code (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function countShipmentAsync($start_date, $end_date, $date_type = null, $client_code = null, $carrier_code = null)
    {
        return $this->countShipmentAsyncWithHttpInfo($start_date, $end_date, $date_type, $client_code, $carrier_code)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation countShipmentAsyncWithHttpInfo
     *
     * Count
     *
     * @param  string $start_date Start date, required (max range is 31 days) (required)
     * @param  string $end_date End date, required (max range is 31 days) (required)
     * @param  string $date_type Date type: ProcessedOn (default), CreatedOn, ShipDate (optional)
     * @param  string $client_code Client code (optional)
     * @param  string $carrier_code Carrier code (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function countShipmentAsyncWithHttpInfo($start_date, $end_date, $date_type = null, $client_code = null, $carrier_code = null)
    {
        $returnType = 'int';
        $request = $this->countShipmentRequest($start_date, $end_date, $date_type, $client_code, $carrier_code);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'countShipment'
     *
     * @param  string $start_date Start date, required (max range is 31 days) (required)
     * @param  string $end_date End date, required (max range is 31 days) (required)
     * @param  string $date_type Date type: ProcessedOn (default), CreatedOn, ShipDate (optional)
     * @param  string $client_code Client code (optional)
     * @param  string $carrier_code Carrier code (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function countShipmentRequest($start_date, $end_date, $date_type = null, $client_code = null, $carrier_code = null)
    {
        // verify the required parameter 'start_date' is set
        if ($start_date === null || (is_array($start_date) && count($start_date) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $start_date when calling countShipment'
            );
        }
        // verify the required parameter 'end_date' is set
        if ($end_date === null || (is_array($end_date) && count($end_date) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $end_date when calling countShipment'
            );
        }

        $resourcePath = '/api/v3/shipments/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($start_date !== null) {
            $queryParams['startDate'] = ObjectSerializer::toQueryValue($start_date, null);
        }
        // query params
        if ($end_date !== null) {
            $queryParams['endDate'] = ObjectSerializer::toQueryValue($end_date, null);
        }
        // query params
        if ($date_type !== null) {
            $queryParams['dateType'] = ObjectSerializer::toQueryValue($date_type, null);
        }
        // query params
        if ($client_code !== null) {
            $queryParams['clientCode'] = ObjectSerializer::toQueryValue($client_code, null);
        }
        // query params
        if ($carrier_code !== null) {
            $queryParams['carrierCode'] = ObjectSerializer::toQueryValue($carrier_code, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-secret-key');
        if ($apiKey !== null) {
            $headers['x-secret-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createShipment
     *
     * Create shipment
     *
     * @param \Fulfillment\StraightShip\Client\Model\InputOrder $body Shipment  to create (required)
     * @param  string $duplicate_handling Duplicate handling ( by transaction number)              0 - Exception on duplicate (default)              1 - Allow duplicates if not closed              2 - Overwrite if duplicate not closed              3 - System reserved for internal use              4 - Overwrite if duplicate not in processed state              5 - Return existing label if processed, otherwise overwrite (optional, default to Exception)
     * @param  string $error_label_mode Error label modeL 0 - None, 1 - PDF, 2 - ZPL (optional, default to None)
     * @param  string $label_pdf_conversion Label pdf conversion: 0 - Default, 1 - Enabled, 2 - Disabled (optional, default to Default)
     * @param  string $label_preference Label preference (support depends on carrier): 0 - ZPL, 1 - PDF, 2 - AZPL, 3 - BZPL, 4 - EPL, 5 - DPL, 6 - PDF (optional)
     * @param  bool $no_lock Do not use distributed locking for duplicate check (if used, duplicate check should be done by calling system) (optional, default to false)
     * @param  bool $import_only Import order and leave in not processed state (optional, default to false)
     * @param  bool $label_url Generate labels as URL (for internal use only) (optional, default to false)
     * @param  bool $dry_run Do not save results to database (optional, default to false)
     * @param  string $printer_key Id of printer used to process order (optional)
     *
     * @throws \Fulfillment\StraightShip\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Fulfillment\StraightShip\Client\Model\CreateLabelResult
     */
    public function createShipment($body, $duplicate_handling = 'Exception', $error_label_mode = 'None', $label_pdf_conversion = 'Default', $label_preference = null, $no_lock = 'false', $import_only = 'false', $label_url = 'false', $dry_run = 'false', $printer_key = null)
    {
        list($response) = $this->createShipmentWithHttpInfo($body, $duplicate_handling, $error_label_mode, $label_pdf_conversion, $label_preference, $no_lock, $import_only, $label_url, $dry_run, $printer_key);
        return $response;
    }

    /**
     * Operation createShipmentWithHttpInfo
     *
     * Create shipment
     *
     * @param \Fulfillment\StraightShip\Client\Model\InputOrder $body Shipment  to create (required)
     * @param  string $duplicate_handling Duplicate handling ( by transaction number)              0 - Exception on duplicate (default)              1 - Allow duplicates if not closed              2 - Overwrite if duplicate not closed              3 - System reserved for internal use              4 - Overwrite if duplicate not in processed state              5 - Return existing label if processed, otherwise overwrite (optional, default to Exception)
     * @param  string $error_label_mode Error label modeL 0 - None, 1 - PDF, 2 - ZPL (optional, default to None)
     * @param  string $label_pdf_conversion Label pdf conversion: 0 - Default, 1 - Enabled, 2 - Disabled (optional, default to Default)
     * @param  string $label_preference Label preference (support depends on carrier): 0 - ZPL, 1 - PDF, 2 - AZPL, 3 - BZPL, 4 - EPL, 5 - DPL, 6 - PDF (optional)
     * @param  bool $no_lock Do not use distributed locking for duplicate check (if used, duplicate check should be done by calling system) (optional, default to false)
     * @param  bool $import_only Import order and leave in not processed state (optional, default to false)
     * @param  bool $label_url Generate labels as URL (for internal use only) (optional, default to false)
     * @param  bool $dry_run Do not save results to database (optional, default to false)
     * @param  string $printer_key Id of printer used to process order (optional)
     *
     * @throws \Fulfillment\StraightShip\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of Fulfillment\StraightShip\Client\Model\CreateLabelResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function createShipmentWithHttpInfo($body, $duplicate_handling = 'Exception', $error_label_mode = 'None', $label_pdf_conversion = 'Default', $label_preference = null, $no_lock = 'false', $import_only = 'false', $label_url = 'false', $dry_run = 'false', $printer_key = null)
    {
        $returnType = CreateLabelResult::class;
        $request = $this->createShipmentRequest($body, $duplicate_handling, $error_label_mode, $label_pdf_conversion, $label_preference, $no_lock, $import_only, $label_url, $dry_run, $printer_key);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        CreateLabelResult::class,
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createShipmentAsync
     *
     * Create shipment
     *
     * @param \Fulfillment\StraightShip\Client\Model\InputOrder $body Shipment  to create (required)
     * @param  string $duplicate_handling Duplicate handling ( by transaction number)              0 - Exception on duplicate (default)              1 - Allow duplicates if not closed              2 - Overwrite if duplicate not closed              3 - System reserved for internal use              4 - Overwrite if duplicate not in processed state              5 - Return existing label if processed, otherwise overwrite (optional, default to Exception)
     * @param  string $error_label_mode Error label modeL 0 - None, 1 - PDF, 2 - ZPL (optional, default to None)
     * @param  string $label_pdf_conversion Label pdf conversion: 0 - Default, 1 - Enabled, 2 - Disabled (optional, default to Default)
     * @param  string $label_preference Label preference (support depends on carrier): 0 - ZPL, 1 - PDF, 2 - AZPL, 3 - BZPL, 4 - EPL, 5 - DPL, 6 - PDF (optional)
     * @param  bool $no_lock Do not use distributed locking for duplicate check (if used, duplicate check should be done by calling system) (optional, default to false)
     * @param  bool $import_only Import order and leave in not processed state (optional, default to false)
     * @param  bool $label_url Generate labels as URL (for internal use only) (optional, default to false)
     * @param  bool $dry_run Do not save results to database (optional, default to false)
     * @param  string $printer_key Id of printer used to process order (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createShipmentAsync($body, $duplicate_handling = 'Exception', $error_label_mode = 'None', $label_pdf_conversion = 'Default', $label_preference = null, $no_lock = 'false', $import_only = 'false', $label_url = 'false', $dry_run = 'false', $printer_key = null)
    {
        return $this->createShipmentAsyncWithHttpInfo($body, $duplicate_handling, $error_label_mode, $label_pdf_conversion, $label_preference, $no_lock, $import_only, $label_url, $dry_run, $printer_key)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createShipmentAsyncWithHttpInfo
     *
     * Create shipment
     *
     * @param \Fulfillment\StraightShip\Client\Model\InputOrder $body Shipment  to create (required)
     * @param  string $duplicate_handling Duplicate handling ( by transaction number)              0 - Exception on duplicate (default)              1 - Allow duplicates if not closed              2 - Overwrite if duplicate not closed              3 - System reserved for internal use              4 - Overwrite if duplicate not in processed state              5 - Return existing label if processed, otherwise overwrite (optional, default to Exception)
     * @param  string $error_label_mode Error label modeL 0 - None, 1 - PDF, 2 - ZPL (optional, default to None)
     * @param  string $label_pdf_conversion Label pdf conversion: 0 - Default, 1 - Enabled, 2 - Disabled (optional, default to Default)
     * @param  string $label_preference Label preference (support depends on carrier): 0 - ZPL, 1 - PDF, 2 - AZPL, 3 - BZPL, 4 - EPL, 5 - DPL, 6 - PDF (optional)
     * @param  bool $no_lock Do not use distributed locking for duplicate check (if used, duplicate check should be done by calling system) (optional, default to false)
     * @param  bool $import_only Import order and leave in not processed state (optional, default to false)
     * @param  bool $label_url Generate labels as URL (for internal use only) (optional, default to false)
     * @param  bool $dry_run Do not save results to database (optional, default to false)
     * @param  string $printer_key Id of printer used to process order (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createShipmentAsyncWithHttpInfo($body, $duplicate_handling = 'Exception', $error_label_mode = 'None', $label_pdf_conversion = 'Default', $label_preference = null, $no_lock = 'false', $import_only = 'false', $label_url = 'false', $dry_run = 'false', $printer_key = null)
    {
        $returnType = CreateLabelResult::class;
        $request = $this->createShipmentRequest($body, $duplicate_handling, $error_label_mode, $label_pdf_conversion, $label_preference, $no_lock, $import_only, $label_url, $dry_run, $printer_key);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createShipment'
     *
     * @param \Fulfillment\StraightShip\Client\Model\InputOrder $body Shipment  to create (required)
     * @param  string $duplicate_handling Duplicate handling ( by transaction number)              0 - Exception on duplicate (default)              1 - Allow duplicates if not closed              2 - Overwrite if duplicate not closed              3 - System reserved for internal use              4 - Overwrite if duplicate not in processed state              5 - Return existing label if processed, otherwise overwrite (optional, default to Exception)
     * @param  string $error_label_mode Error label modeL 0 - None, 1 - PDF, 2 - ZPL (optional, default to None)
     * @param  string $label_pdf_conversion Label pdf conversion: 0 - Default, 1 - Enabled, 2 - Disabled (optional, default to Default)
     * @param  string $label_preference Label preference (support depends on carrier): 0 - ZPL, 1 - PDF, 2 - AZPL, 3 - BZPL, 4 - EPL, 5 - DPL, 6 - PDF (optional)
     * @param  bool $no_lock Do not use distributed locking for duplicate check (if used, duplicate check should be done by calling system) (optional, default to false)
     * @param  bool $import_only Import order and leave in not processed state (optional, default to false)
     * @param  bool $label_url Generate labels as URL (for internal use only) (optional, default to false)
     * @param  bool $dry_run Do not save results to database (optional, default to false)
     * @param  string $printer_key Id of printer used to process order (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createShipmentRequest($body, $duplicate_handling = 'Exception', $error_label_mode = 'None', $label_pdf_conversion = 'Default', $label_preference = null, $no_lock = 'false', $import_only = 'false', $label_url = 'false', $dry_run = 'false', $printer_key = null)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling createShipment'
            );
        }

        $resourcePath = '/api/v3/shipments/create';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($duplicate_handling !== null) {
            $queryParams['duplicateHandling'] = ObjectSerializer::toQueryValue($duplicate_handling, null);
        }
        // query params
        if ($error_label_mode !== null) {
            $queryParams['errorLabelMode'] = ObjectSerializer::toQueryValue($error_label_mode, null);
        }
        // query params
        if ($label_pdf_conversion !== null) {
            $queryParams['labelPdfConversion'] = ObjectSerializer::toQueryValue($label_pdf_conversion, null);
        }
        // query params
        if ($label_preference !== null) {
            $queryParams['labelPreference'] = ObjectSerializer::toQueryValue($label_preference, null);
        }
        // query params
        if ($no_lock !== null) {
            $queryParams['noLock'] = ObjectSerializer::toQueryValue($no_lock, null);
        }
        // query params
        if ($import_only !== null) {
            $queryParams['importOnly'] = ObjectSerializer::toQueryValue($import_only, null);
        }
        // query params
        if ($label_url !== null) {
            $queryParams['labelUrl'] = ObjectSerializer::toQueryValue($label_url, null);
        }
        // query params
        if ($dry_run !== null) {
            $queryParams['dryRun'] = ObjectSerializer::toQueryValue($dry_run, null);
        }
        // query params
        if ($printer_key !== null) {
            $queryParams['printerKey'] = ObjectSerializer::toQueryValue($printer_key, null);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml'],
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-secret-key');
        if ($apiKey !== null) {
            $headers['x-secret-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation delete
     *
     * Delete shipment
     *
     * @param  int $shipment_id Shipment id returned from create order call (required)
     * @param  bool $leave_as_open leave_as_open (optional, default to false)
     *
     * @throws \Fulfillment\StraightShip\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Fulfillment\StraightShip\Client\Model\VoidShipmentResult
     */
    public function delete($shipment_id, $leave_as_open = 'false')
    {
        list($response) = $this->deleteWithHttpInfo($shipment_id, $leave_as_open);
        return $response;
    }

    /**
     * Operation deleteWithHttpInfo
     *
     * Delete shipment
     *
     * @param  int $shipment_id Shipment id returned from create order call (required)
     * @param  bool $leave_as_open (optional, default to false)
     *
     * @throws \Fulfillment\StraightShip\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of Fulfillment\StraightShip\Client\Model\VoidShipmentResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteWithHttpInfo($shipment_id, $leave_as_open = 'false')
    {
        $returnType = VoidShipmentResult::class;
        $request = $this->deleteRequest($shipment_id, $leave_as_open);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        VoidShipmentResult::class,
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteAsync
     *
     * Delete shipment
     *
     * @param  int $shipment_id Shipment id returned from create order call (required)
     * @param  bool $leave_as_open (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteAsync($shipment_id, $leave_as_open = 'false')
    {
        return $this->deleteAsyncWithHttpInfo($shipment_id, $leave_as_open)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteAsyncWithHttpInfo
     *
     * Delete shipment
     *
     * @param  int $shipment_id Shipment id returned from create order call (required)
     * @param  bool $leave_as_open (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteAsyncWithHttpInfo($shipment_id, $leave_as_open = 'false')
    {
        $returnType = VoidShipmentResult::class;
        $request = $this->deleteRequest($shipment_id, $leave_as_open);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'delete'
     *
     * @param  int $shipment_id Shipment id returned from create order call (required)
     * @param  bool $leave_as_open (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteRequest($shipment_id, $leave_as_open = 'false')
    {
        // verify the required parameter 'shipment_id' is set
        if ($shipment_id === null || (is_array($shipment_id) && count($shipment_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $shipment_id when calling delete'
            );
        }

        $resourcePath = '/api/v3/shipments/{shipmentId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($leave_as_open !== null) {
            $queryParams['leaveAsOpen'] = ObjectSerializer::toQueryValue($leave_as_open, null);
        }

        // path params
        if ($shipment_id !== null) {
            $resourcePath = str_replace(
                '{' . 'shipmentId' . '}',
                ObjectSerializer::toPathValue($shipment_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-secret-key');
        if ($apiKey !== null) {
            $headers['x-secret-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation estimateShipment
     *
     * Create shipment
     *
     * @param \Fulfillment\StraightShip\Client\Model\InputOrder $body Shipment  to create (required)
     * @param  string $duplicate_handling Duplicate handling ( by transaction number)              0 - Exception on duplicate (default)              1 - Allow duplicates if not closed              2 - Overwrite if duplicate not closed              3 - System reserved for internal use              4 - Overwrite if duplicate not in processed state              5 - Return existing label if processed, otherwise overwrite (optional, default to Exception)
     * @param  bool $no_lock Do not use distributed locking for duplicate check (if used, duplicate check should be done by calling system) (optional, default to false)
     *
     * @throws \Fulfillment\StraightShip\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Fulfillment\StraightShip\Client\Model\RatesResult
     */
    public function estimateShipment($body, $duplicate_handling = 'Exception', $no_lock = 'false')
    {
        list($response) = $this->estimateShipmentWithHttpInfo($body, $duplicate_handling, $no_lock);
        return $response;
    }

    /**
     * Operation estimateShipmentWithHttpInfo
     *
     * Create shipment
     *
     * @param \Fulfillment\StraightShip\Client\Model\InputOrder $body Shipment  to create (required)
     * @param  string $duplicate_handling Duplicate handling ( by transaction number)              0 - Exception on duplicate (default)              1 - Allow duplicates if not closed              2 - Overwrite if duplicate not closed              3 - System reserved for internal use              4 - Overwrite if duplicate not in processed state              5 - Return existing label if processed, otherwise overwrite (optional, default to Exception)
     * @param  bool $no_lock Do not use distributed locking for duplicate check (if used, duplicate check should be done by calling system) (optional, default to false)
     *
     * @throws \Fulfillment\StraightShip\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of Fulfillment\StraightShip\Client\Model\RatesResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function estimateShipmentWithHttpInfo($body, $duplicate_handling = 'Exception', $no_lock = 'false')
    {
        $returnType = RatesResult::class;
        $request = $this->estimateShipmentRequest($body, $duplicate_handling, $no_lock);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        RatesResult::class,
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation estimateShipmentAsync
     *
     * Create shipment
     *
     * @param \Fulfillment\StraightShip\Client\Model\InputOrder $body Shipment  to create (required)
     * @param  string $duplicate_handling Duplicate handling ( by transaction number)              0 - Exception on duplicate (default)              1 - Allow duplicates if not closed              2 - Overwrite if duplicate not closed              3 - System reserved for internal use              4 - Overwrite if duplicate not in processed state              5 - Return existing label if processed, otherwise overwrite (optional, default to Exception)
     * @param  bool $no_lock Do not use distributed locking for duplicate check (if used, duplicate check should be done by calling system) (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function estimateShipmentAsync($body, $duplicate_handling = 'Exception', $no_lock = 'false')
    {
        return $this->estimateShipmentAsyncWithHttpInfo($body, $duplicate_handling, $no_lock)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation estimateShipmentAsyncWithHttpInfo
     *
     * Create shipment
     *
     * @param \Fulfillment\StraightShip\Client\Model\InputOrder $body Shipment  to create (required)
     * @param  string $duplicate_handling Duplicate handling ( by transaction number)              0 - Exception on duplicate (default)              1 - Allow duplicates if not closed              2 - Overwrite if duplicate not closed              3 - System reserved for internal use              4 - Overwrite if duplicate not in processed state              5 - Return existing label if processed, otherwise overwrite (optional, default to Exception)
     * @param  bool $no_lock Do not use distributed locking for duplicate check (if used, duplicate check should be done by calling system) (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function estimateShipmentAsyncWithHttpInfo($body, $duplicate_handling = 'Exception', $no_lock = 'false')
    {
        $returnType = RatesResult::class;
        $request = $this->estimateShipmentRequest($body, $duplicate_handling, $no_lock);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'estimateShipment'
     *
     * @param \Fulfillment\StraightShip\Client\Model\InputOrder $body Shipment  to create (required)
     * @param  string $duplicate_handling Duplicate handling ( by transaction number)              0 - Exception on duplicate (default)              1 - Allow duplicates if not closed              2 - Overwrite if duplicate not closed              3 - System reserved for internal use              4 - Overwrite if duplicate not in processed state              5 - Return existing label if processed, otherwise overwrite (optional, default to Exception)
     * @param  bool $no_lock Do not use distributed locking for duplicate check (if used, duplicate check should be done by calling system) (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function estimateShipmentRequest($body, $duplicate_handling = 'Exception', $no_lock = 'false')
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling estimateShipment'
            );
        }

        $resourcePath = '/api/v3/shipments/estimate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($duplicate_handling !== null) {
            $queryParams['duplicateHandling'] = ObjectSerializer::toQueryValue($duplicate_handling, null);
        }
        // query params
        if ($no_lock !== null) {
            $queryParams['noLock'] = ObjectSerializer::toQueryValue($no_lock, null);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml'],
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-secret-key');
        if ($apiKey !== null) {
            $headers['x-secret-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getShipment
     *
     * Get shipment
     *
     * @param  int $shipment_id Order id returned from create order call (required)
     * @param  string $label_pdf_conversion Label pdf conversion (optional, default to Default)
     * @param  string $label_preference Label preference (optional)
     * @param  bool $fetch_optional_documents Fetch optional documents (optional, default to false)
     *
     * @throws \Fulfillment\StraightShip\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Fulfillment\StraightShip\Client\Model\Order
     */
    public function getShipment($shipment_id, $label_pdf_conversion = 'Default', $label_preference = null, $fetch_optional_documents = 'false')
    {
        list($response) = $this->getShipmentWithHttpInfo($shipment_id, $label_pdf_conversion, $label_preference, $fetch_optional_documents);
        return $response;
    }

    /**
     * Operation getShipmentWithHttpInfo
     *
     * Get shipment
     *
     * @param  int $shipment_id Order id returned from create order call (required)
     * @param  string $label_pdf_conversion Label pdf conversion (optional, default to Default)
     * @param  string $label_preference Label preference (optional)
     * @param  bool $fetch_optional_documents Fetch optional documents (optional, default to false)
     *
     * @throws \Fulfillment\StraightShip\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of Fulfillment\StraightShip\Client\Model\Order, HTTP status code, HTTP response headers (array of strings)
     */
    public function getShipmentWithHttpInfo($shipment_id, $label_pdf_conversion = 'Default', $label_preference = null, $fetch_optional_documents = 'false')
    {
        $returnType = Order::class;
        $request = $this->getShipmentRequest($shipment_id, $label_pdf_conversion, $label_preference, $fetch_optional_documents);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        Order::class,
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getShipmentAsync
     *
     * Get shipment
     *
     * @param  int $shipment_id Order id returned from create order call (required)
     * @param  string $label_pdf_conversion Label pdf conversion (optional, default to Default)
     * @param  string $label_preference Label preference (optional)
     * @param  bool $fetch_optional_documents Fetch optional documents (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getShipmentAsync($shipment_id, $label_pdf_conversion = 'Default', $label_preference = null, $fetch_optional_documents = 'false')
    {
        return $this->getShipmentAsyncWithHttpInfo($shipment_id, $label_pdf_conversion, $label_preference, $fetch_optional_documents)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getShipmentAsyncWithHttpInfo
     *
     * Get shipment
     *
     * @param  int $shipment_id Order id returned from create order call (required)
     * @param  string $label_pdf_conversion Label pdf conversion (optional, default to Default)
     * @param  string $label_preference Label preference (optional)
     * @param  bool $fetch_optional_documents Fetch optional documents (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getShipmentAsyncWithHttpInfo($shipment_id, $label_pdf_conversion = 'Default', $label_preference = null, $fetch_optional_documents = 'false')
    {
        $returnType = Order::class;
        $request = $this->getShipmentRequest($shipment_id, $label_pdf_conversion, $label_preference, $fetch_optional_documents);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getShipment'
     *
     * @param  int $shipment_id Order id returned from create order call (required)
     * @param  string $label_pdf_conversion Label pdf conversion (optional, default to Default)
     * @param  string $label_preference Label preference (optional)
     * @param  bool $fetch_optional_documents Fetch optional documents (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getShipmentRequest($shipment_id, $label_pdf_conversion = 'Default', $label_preference = null, $fetch_optional_documents = 'false')
    {
        // verify the required parameter 'shipment_id' is set
        if ($shipment_id === null || (is_array($shipment_id) && count($shipment_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $shipment_id when calling getShipment'
            );
        }

        $resourcePath = '/api/v3/shipments/{shipmentId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($label_pdf_conversion !== null) {
            $queryParams['labelPdfConversion'] = ObjectSerializer::toQueryValue($label_pdf_conversion, null);
        }
        // query params
        if ($label_preference !== null) {
            $queryParams['labelPreference'] = ObjectSerializer::toQueryValue($label_preference, null);
        }
        // query params
        if ($fetch_optional_documents !== null) {
            $queryParams['fetchOptionalDocuments'] = ObjectSerializer::toQueryValue($fetch_optional_documents, null);
        }

        // path params
        if ($shipment_id !== null) {
            $resourcePath = str_replace(
                '{' . 'shipmentId' . '}',
                ObjectSerializer::toPathValue($shipment_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-secret-key');
        if ($apiKey !== null) {
            $headers['x-secret-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation importAndProcess
     *
     * Import shipment
     *
     * @param  string $mode Import mode (required)
     * @param  string $search_value Value to search (required)
     * @param  string $label_pdf_conversion Label pdf conversion (optional, default to Default)
     * @param  int $client_box_id Client box id to apply (optional)
     * @param  bool $apply_client_box apply_client_box (optional, default to true)
     * @param  bool $apply_client_box_content_weight apply_client_box_content_weight (optional, default to false)
     * @param  string $batch_number batch_number (optional)
     * @param  string $printer_key Printer key to schedule for printing (optional)
     * @param  string $label_preference label_preference (optional)
     * @param  string $command Process command (default ImportAndProcess) (optional)
     * @param  bool $reimport reimport (optional, default to false)
     * @param  bool $no_lock Do not use distributed locking for duplicate check (if used, duplicate check should be done by calling system) (optional, default to false)
     *
     * @throws \Fulfillment\StraightShip\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Fulfillment\StraightShip\Client\Model\Order
     */
    public function importAndProcess($mode, $search_value, $label_pdf_conversion = 'Default', $client_box_id = null, $apply_client_box = 'true', $apply_client_box_content_weight = 'false', $batch_number = null, $printer_key = null, $label_preference = null, $command = null, $reimport = 'false', $no_lock = 'false')
    {
        list($response) = $this->importAndProcessWithHttpInfo($mode, $search_value, $label_pdf_conversion, $client_box_id, $apply_client_box, $apply_client_box_content_weight, $batch_number, $printer_key, $label_preference, $command, $reimport, $no_lock);
        return $response;
    }

    /**
     * Operation importAndProcessWithHttpInfo
     *
     * Import shipment
     *
     * @param  string $mode Import mode (required)
     * @param  string $search_value Value to search (required)
     * @param  string $label_pdf_conversion Label pdf conversion (optional, default to Default)
     * @param  int $client_box_id Client box id to apply (optional)
     * @param  bool $apply_client_box (optional, default to true)
     * @param  bool $apply_client_box_content_weight (optional, default to false)
     * @param  string $batch_number (optional)
     * @param  string $printer_key Printer key to schedule for printing (optional)
     * @param  string $label_preference (optional)
     * @param  string $command Process command (default ImportAndProcess) (optional)
     * @param  bool $reimport (optional, default to false)
     * @param  bool $no_lock Do not use distributed locking for duplicate check (if used, duplicate check should be done by calling system) (optional, default to false)
     *
     * @throws \Fulfillment\StraightShip\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of Fulfillment\StraightShip\Client\Model\Order, HTTP status code, HTTP response headers (array of strings)
     */
    public function importAndProcessWithHttpInfo($mode, $search_value, $label_pdf_conversion = 'Default', $client_box_id = null, $apply_client_box = 'true', $apply_client_box_content_weight = 'false', $batch_number = null, $printer_key = null, $label_preference = null, $command = null, $reimport = 'false', $no_lock = 'false')
    {
        $returnType = Order::class;
        $request = $this->importAndProcessRequest($mode, $search_value, $label_pdf_conversion, $client_box_id, $apply_client_box, $apply_client_box_content_weight, $batch_number, $printer_key, $label_preference, $command, $reimport, $no_lock);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        Order::class,
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation importAndProcessAsync
     *
     * Import shipment
     *
     * @param  string $mode Import mode (required)
     * @param  string $search_value Value to search (required)
     * @param  string $label_pdf_conversion Label pdf conversion (optional, default to Default)
     * @param  int $client_box_id Client box id to apply (optional)
     * @param  bool $apply_client_box (optional, default to true)
     * @param  bool $apply_client_box_content_weight (optional, default to false)
     * @param  string $batch_number (optional)
     * @param  string $printer_key Printer key to schedule for printing (optional)
     * @param  string $label_preference (optional)
     * @param  string $command Process command (default ImportAndProcess) (optional)
     * @param  bool $reimport (optional, default to false)
     * @param  bool $no_lock Do not use distributed locking for duplicate check (if used, duplicate check should be done by calling system) (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function importAndProcessAsync($mode, $search_value, $label_pdf_conversion = 'Default', $client_box_id = null, $apply_client_box = 'true', $apply_client_box_content_weight = 'false', $batch_number = null, $printer_key = null, $label_preference = null, $command = null, $reimport = 'false', $no_lock = 'false')
    {
        return $this->importAndProcessAsyncWithHttpInfo($mode, $search_value, $label_pdf_conversion, $client_box_id, $apply_client_box, $apply_client_box_content_weight, $batch_number, $printer_key, $label_preference, $command, $reimport, $no_lock)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation importAndProcessAsyncWithHttpInfo
     *
     * Import shipment
     *
     * @param  string $mode Import mode (required)
     * @param  string $search_value Value to search (required)
     * @param  string $label_pdf_conversion Label pdf conversion (optional, default to Default)
     * @param  int $client_box_id Client box id to apply (optional)
     * @param  bool $apply_client_box (optional, default to true)
     * @param  bool $apply_client_box_content_weight (optional, default to false)
     * @param  string $batch_number (optional)
     * @param  string $printer_key Printer key to schedule for printing (optional)
     * @param  string $label_preference (optional)
     * @param  string $command Process command (default ImportAndProcess) (optional)
     * @param  bool $reimport (optional, default to false)
     * @param  bool $no_lock Do not use distributed locking for duplicate check (if used, duplicate check should be done by calling system) (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function importAndProcessAsyncWithHttpInfo($mode, $search_value, $label_pdf_conversion = 'Default', $client_box_id = null, $apply_client_box = 'true', $apply_client_box_content_weight = 'false', $batch_number = null, $printer_key = null, $label_preference = null, $command = null, $reimport = 'false', $no_lock = 'false')
    {
        $returnType = Order::class;
        $request = $this->importAndProcessRequest($mode, $search_value, $label_pdf_conversion, $client_box_id, $apply_client_box, $apply_client_box_content_weight, $batch_number, $printer_key, $label_preference, $command, $reimport, $no_lock);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'importAndProcess'
     *
     * @param  string $mode Import mode (required)
     * @param  string $search_value Value to search (required)
     * @param  string $label_pdf_conversion Label pdf conversion (optional, default to Default)
     * @param  int $client_box_id Client box id to apply (optional)
     * @param  bool $apply_client_box (optional, default to true)
     * @param  bool $apply_client_box_content_weight (optional, default to false)
     * @param  string $batch_number (optional)
     * @param  string $printer_key Printer key to schedule for printing (optional)
     * @param  string $label_preference (optional)
     * @param  string $command Process command (default ImportAndProcess) (optional)
     * @param  bool $reimport (optional, default to false)
     * @param  bool $no_lock Do not use distributed locking for duplicate check (if used, duplicate check should be done by calling system) (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function importAndProcessRequest($mode, $search_value, $label_pdf_conversion = 'Default', $client_box_id = null, $apply_client_box = 'true', $apply_client_box_content_weight = 'false', $batch_number = null, $printer_key = null, $label_preference = null, $command = null, $reimport = 'false', $no_lock = 'false')
    {
        // verify the required parameter 'mode' is set
        if ($mode === null || (is_array($mode) && count($mode) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $mode when calling importAndProcess'
            );
        }
        // verify the required parameter 'search_value' is set
        if ($search_value === null || (is_array($search_value) && count($search_value) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $search_value when calling importAndProcess'
            );
        }

        $resourcePath = '/api/v3/shipments/importandprocess';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($mode !== null) {
            $queryParams['mode'] = ObjectSerializer::toQueryValue($mode, null);
        }
        // query params
        if ($search_value !== null) {
            $queryParams['searchValue'] = ObjectSerializer::toQueryValue($search_value, null);
        }
        // query params
        if ($label_pdf_conversion !== null) {
            $queryParams['labelPdfConversion'] = ObjectSerializer::toQueryValue($label_pdf_conversion, null);
        }
        // query params
        if ($client_box_id !== null) {
            $queryParams['clientBoxId'] = ObjectSerializer::toQueryValue($client_box_id, 'int32');
        }
        // query params
        if ($apply_client_box !== null) {
            $queryParams['applyClientBox'] = ObjectSerializer::toQueryValue($apply_client_box, null);
        }
        // query params
        if ($apply_client_box_content_weight !== null) {
            $queryParams['applyClientBoxContentWeight'] = ObjectSerializer::toQueryValue($apply_client_box_content_weight, null);
        }
        // query params
        if ($batch_number !== null) {
            $queryParams['batchNumber'] = ObjectSerializer::toQueryValue($batch_number, null);
        }
        // query params
        if ($printer_key !== null) {
            $queryParams['printerKey'] = ObjectSerializer::toQueryValue($printer_key, null);
        }
        // query params
        if ($label_preference !== null) {
            $queryParams['labelPreference'] = ObjectSerializer::toQueryValue($label_preference, null);
        }
        // query params
        if ($command !== null) {
            $queryParams['command'] = ObjectSerializer::toQueryValue($command, null);
        }
        // query params
        if ($reimport !== null) {
            $queryParams['reimport'] = ObjectSerializer::toQueryValue($reimport, null);
        }
        // query params
        if ($no_lock !== null) {
            $queryParams['noLock'] = ObjectSerializer::toQueryValue($no_lock, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-secret-key');
        if ($apiKey !== null) {
            $headers['x-secret-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listShipment
     *
     * List shipments
     *
     * @param  string $start_date Start date (optional)
     * @param  string $end_date End date (optional)
     * @param  string $date_type Date type: ProcessedOn (default), CreatedOn, ShipDate (optional)
     * @param  string $client_code Client code (optional)
     * @param  string $carrier_code Carrier code (optional)
     * @param  string $transaction_number Transaction number (optional)
     * @param  string $tracking_number Tracking number (optional)
     * @param  string $customer_order Customer order (optional)
     * @param  string $customer_po Customer po (optional)
     * @param  string $batch_number Batch number (optional)
     * @param  string $status status (optional)
     * @param  int $page_index Zero-based page index (optional, default to 0)
     * @param  int $items_per_page Shipment count per page (up to 1000) (optional, default to 1000)
     *
     * @throws \Fulfillment\StraightShip\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Fulfillment\StraightShip\Client\Model\Order[]
     */
    public function listShipment($start_date = null, $end_date = null, $date_type = null, $client_code = null, $carrier_code = null, $transaction_number = null, $tracking_number = null, $customer_order = null, $customer_po = null, $batch_number = null, $status = null, $page_index = '0', $items_per_page = '1000')
    {
        list($response) = $this->listShipmentWithHttpInfo($start_date, $end_date, $date_type, $client_code, $carrier_code, $transaction_number, $tracking_number, $customer_order, $customer_po, $batch_number, $status, $page_index, $items_per_page);
        return $response;
    }

    /**
     * Operation listShipmentWithHttpInfo
     *
     * List shipments
     *
     * @param  string $start_date Start date (optional)
     * @param  string $end_date End date (optional)
     * @param  string $date_type Date type: ProcessedOn (default), CreatedOn, ShipDate (optional)
     * @param  string $client_code Client code (optional)
     * @param  string $carrier_code Carrier code (optional)
     * @param  string $transaction_number Transaction number (optional)
     * @param  string $tracking_number Tracking number (optional)
     * @param  string $customer_order Customer order (optional)
     * @param  string $customer_po Customer po (optional)
     * @param  string $batch_number Batch number (optional)
     * @param  string $status (optional)
     * @param  int $page_index Zero-based page index (optional, default to 0)
     * @param  int $items_per_page Shipment count per page (up to 1000) (optional, default to 1000)
     *
     * @throws \Fulfillment\StraightShip\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of Fulfillment\StraightShip\Client\Model\Order[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listShipmentWithHttpInfo($start_date = null, $end_date = null, $date_type = null, $client_code = null, $carrier_code = null, $transaction_number = null, $tracking_number = null, $customer_order = null, $customer_po = null, $batch_number = null, $status = null, $page_index = '0', $items_per_page = '1000')
    {
        $returnType = 'Fulfillment\StraightShip\Client\Model\Order[]';
        $request = $this->listShipmentRequest($start_date, $end_date, $date_type, $client_code, $carrier_code, $transaction_number, $tracking_number, $customer_order, $customer_po, $batch_number, $status, $page_index, $items_per_page);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'Fulfillment\StraightShip\Client\Model\Order[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listShipmentAsync
     *
     * List shipments
     *
     * @param  string $start_date Start date (optional)
     * @param  string $end_date End date (optional)
     * @param  string $date_type Date type: ProcessedOn (default), CreatedOn, ShipDate (optional)
     * @param  string $client_code Client code (optional)
     * @param  string $carrier_code Carrier code (optional)
     * @param  string $transaction_number Transaction number (optional)
     * @param  string $tracking_number Tracking number (optional)
     * @param  string $customer_order Customer order (optional)
     * @param  string $customer_po Customer po (optional)
     * @param  string $batch_number Batch number (optional)
     * @param  string $status (optional)
     * @param  int $page_index Zero-based page index (optional, default to 0)
     * @param  int $items_per_page Shipment count per page (up to 1000) (optional, default to 1000)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listShipmentAsync($start_date = null, $end_date = null, $date_type = null, $client_code = null, $carrier_code = null, $transaction_number = null, $tracking_number = null, $customer_order = null, $customer_po = null, $batch_number = null, $status = null, $page_index = '0', $items_per_page = '1000')
    {
        return $this->listShipmentAsyncWithHttpInfo($start_date, $end_date, $date_type, $client_code, $carrier_code, $transaction_number, $tracking_number, $customer_order, $customer_po, $batch_number, $status, $page_index, $items_per_page)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listShipmentAsyncWithHttpInfo
     *
     * List shipments
     *
     * @param  string $start_date Start date (optional)
     * @param  string $end_date End date (optional)
     * @param  string $date_type Date type: ProcessedOn (default), CreatedOn, ShipDate (optional)
     * @param  string $client_code Client code (optional)
     * @param  string $carrier_code Carrier code (optional)
     * @param  string $transaction_number Transaction number (optional)
     * @param  string $tracking_number Tracking number (optional)
     * @param  string $customer_order Customer order (optional)
     * @param  string $customer_po Customer po (optional)
     * @param  string $batch_number Batch number (optional)
     * @param  string $status (optional)
     * @param  int $page_index Zero-based page index (optional, default to 0)
     * @param  int $items_per_page Shipment count per page (up to 1000) (optional, default to 1000)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listShipmentAsyncWithHttpInfo($start_date = null, $end_date = null, $date_type = null, $client_code = null, $carrier_code = null, $transaction_number = null, $tracking_number = null, $customer_order = null, $customer_po = null, $batch_number = null, $status = null, $page_index = '0', $items_per_page = '1000')
    {
        $returnType = 'Fulfillment\StraightShip\Client\Model\Order[]';
        $request = $this->listShipmentRequest($start_date, $end_date, $date_type, $client_code, $carrier_code, $transaction_number, $tracking_number, $customer_order, $customer_po, $batch_number, $status, $page_index, $items_per_page);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listShipment'
     *
     * @param  string $start_date Start date (optional)
     * @param  string $end_date End date (optional)
     * @param  string $date_type Date type: ProcessedOn (default), CreatedOn, ShipDate (optional)
     * @param  string $client_code Client code (optional)
     * @param  string $carrier_code Carrier code (optional)
     * @param  string $transaction_number Transaction number (optional)
     * @param  string $tracking_number Tracking number (optional)
     * @param  string $customer_order Customer order (optional)
     * @param  string $customer_po Customer po (optional)
     * @param  string $batch_number Batch number (optional)
     * @param  string $status (optional)
     * @param  int $page_index Zero-based page index (optional, default to 0)
     * @param  int $items_per_page Shipment count per page (up to 1000) (optional, default to 1000)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listShipmentRequest($start_date = null, $end_date = null, $date_type = null, $client_code = null, $carrier_code = null, $transaction_number = null, $tracking_number = null, $customer_order = null, $customer_po = null, $batch_number = null, $status = null, $page_index = '0', $items_per_page = '1000')
    {

        $resourcePath = '/api/v3/shipments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($start_date !== null) {
            $queryParams['startDate'] = ObjectSerializer::toQueryValue($start_date, null);
        }
        // query params
        if ($end_date !== null) {
            $queryParams['endDate'] = ObjectSerializer::toQueryValue($end_date, null);
        }
        // query params
        if ($date_type !== null) {
            $queryParams['dateType'] = ObjectSerializer::toQueryValue($date_type, null);
        }
        // query params
        if ($client_code !== null) {
            $queryParams['clientCode'] = ObjectSerializer::toQueryValue($client_code, null);
        }
        // query params
        if ($carrier_code !== null) {
            $queryParams['carrierCode'] = ObjectSerializer::toQueryValue($carrier_code, null);
        }
        // query params
        if ($transaction_number !== null) {
            $queryParams['transactionNumber'] = ObjectSerializer::toQueryValue($transaction_number, null);
        }
        // query params
        if ($tracking_number !== null) {
            $queryParams['trackingNumber'] = ObjectSerializer::toQueryValue($tracking_number, null);
        }
        // query params
        if ($customer_order !== null) {
            $queryParams['customerOrder'] = ObjectSerializer::toQueryValue($customer_order, null);
        }
        // query params
        if ($customer_po !== null) {
            $queryParams['customerPO'] = ObjectSerializer::toQueryValue($customer_po, null);
        }
        // query params
        if ($batch_number !== null) {
            $queryParams['batchNumber'] = ObjectSerializer::toQueryValue($batch_number, null);
        }
        // query params
        if ($status !== null) {
            $queryParams['status'] = ObjectSerializer::toQueryValue($status, null);
        }
        // query params
        if ($page_index !== null) {
            $queryParams['pageIndex'] = ObjectSerializer::toQueryValue($page_index, 'int32');
        }
        // query params
        if ($items_per_page !== null) {
            $queryParams['itemsPerPage'] = ObjectSerializer::toQueryValue($items_per_page, 'int32');
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-secret-key');
        if ($apiKey !== null) {
            $headers['x-secret-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation trigger
     *
     * Triggers WMS callback
     *
     * @param  int $shipment_id Order id returned from create order call (required)
     *
     * @throws \Fulfillment\StraightShip\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Fulfillment\StraightShip\Client\Model\OperationResult
     */
    public function trigger($shipment_id)
    {
        list($response) = $this->triggerWithHttpInfo($shipment_id);
        return $response;
    }

    /**
     * Operation triggerWithHttpInfo
     *
     * Triggers WMS callback
     *
     * @param  int $shipment_id Order id returned from create order call (required)
     *
     * @throws \Fulfillment\StraightShip\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of Fulfillment\StraightShip\Client\Model\OperationResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function triggerWithHttpInfo($shipment_id)
    {
        $returnType = OperationResult::class;
        $request = $this->triggerRequest($shipment_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        OperationResult::class,
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        OperationResult::class,
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation triggerAsync
     *
     * Triggers WMS callback
     *
     * @param  int $shipment_id Order id returned from create order call (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function triggerAsync($shipment_id)
    {
        return $this->triggerAsyncWithHttpInfo($shipment_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation triggerAsyncWithHttpInfo
     *
     * Triggers WMS callback
     *
     * @param  int $shipment_id Order id returned from create order call (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function triggerAsyncWithHttpInfo($shipment_id)
    {
        $returnType = OperationResult::class;
        $request = $this->triggerRequest($shipment_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'trigger'
     *
     * @param  int $shipment_id Order id returned from create order call (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function triggerRequest($shipment_id)
    {
        // verify the required parameter 'shipment_id' is set
        if ($shipment_id === null || (is_array($shipment_id) && count($shipment_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $shipment_id when calling trigger'
            );
        }

        $resourcePath = '/api/v3/shipments/{shipmentId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($shipment_id !== null) {
            $resourcePath = str_replace(
                '{' . 'shipmentId' . '}',
                ObjectSerializer::toPathValue($shipment_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-secret-key');
        if ($apiKey !== null) {
            $headers['x-secret-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateShipment
     *
     * Update shipment
     *
     * @param \Fulfillment\StraightShip\Client\Model\InputOrder $body Shipment to update (required)
     * @param  int $shipment_id Shipment id (required)
     *
     * @throws \Fulfillment\StraightShip\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Fulfillment\StraightShip\Client\Model\Order
     */
    public function updateShipment($body, $shipment_id)
    {
        list($response) = $this->updateShipmentWithHttpInfo($body, $shipment_id);
        return $response;
    }

    /**
     * Operation updateShipmentWithHttpInfo
     *
     * Update shipment
     *
     * @param \Fulfillment\StraightShip\Client\Model\InputOrder $body Shipment to update (required)
     * @param  int $shipment_id Shipment id (required)
     *
     * @throws \Fulfillment\StraightShip\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of Fulfillment\StraightShip\Client\Model\Order, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateShipmentWithHttpInfo($body, $shipment_id)
    {
        $returnType = Order::class;
        $request = $this->updateShipmentRequest($body, $shipment_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        Order::class,
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        ApiError::class,
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateShipmentAsync
     *
     * Update shipment
     *
     * @param \Fulfillment\StraightShip\Client\Model\InputOrder $body Shipment to update (required)
     * @param  int $shipment_id Shipment id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateShipmentAsync($body, $shipment_id)
    {
        return $this->updateShipmentAsyncWithHttpInfo($body, $shipment_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateShipmentAsyncWithHttpInfo
     *
     * Update shipment
     *
     * @param \Fulfillment\StraightShip\Client\Model\InputOrder $body Shipment to update (required)
     * @param  int $shipment_id Shipment id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateShipmentAsyncWithHttpInfo($body, $shipment_id)
    {
        $returnType = Order::class;
        $request = $this->updateShipmentRequest($body, $shipment_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateShipment'
     *
     * @param \Fulfillment\StraightShip\Client\Model\InputOrder $body Shipment to update (required)
     * @param  int $shipment_id Shipment id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateShipmentRequest($body, $shipment_id)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling updateShipment'
            );
        }
        // verify the required parameter 'shipment_id' is set
        if ($shipment_id === null || (is_array($shipment_id) && count($shipment_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $shipment_id when calling updateShipment'
            );
        }

        $resourcePath = '/api/v3/shipments/{shipmentId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($shipment_id !== null) {
            $resourcePath = str_replace(
                '{' . 'shipmentId' . '}',
                ObjectSerializer::toPathValue($shipment_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json', 'text/json', 'application/xml', 'text/xml'],
                ['application/json', 'text/json', 'application/xml', 'text/xml']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-secret-key');
        if ($apiKey !== null) {
            $headers['x-secret-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
